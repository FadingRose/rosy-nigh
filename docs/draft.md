## Slot 和 Memory 修正

### 1. 验证是否是 slot 和 memory 阻碍探索

在智能合约的模糊测试（fuzzing）过程中，slot 和 memory 的使用可能会对探索产生阻碍。这是因为：

- **Slot（存储槽）**：智能合约的状态变量通常存储在特定的存储槽中。如果这些存储槽的值在模糊测试过程中被频繁读取或写入，可能会导致状态空间变得复杂，增加探索的难度。
  
- **Memory（内存）**：智能合约在执行过程中会使用内存来存储临时数据。如果内存中的数据被频繁读取或写入，可能会导致状态空间变得复杂，增加探索的难度。

为了验证是否是 slot 和 memory 阻碍了探索，可以进行以下步骤：

1. **观察模糊测试的覆盖率**：如果模糊测试的覆盖率较低，尤其是在某些特定的代码路径上，可能是因为 slot 和 memory 的使用导致了状态空间的复杂性。

2. **分析模糊测试的日志**：查看模糊测试的日志，观察是否有大量的 SLOAD 和 MLOAD 操作。如果这些操作频繁出现，可能是因为 slot 和 memory 的使用导致了状态空间的复杂性。

3. **对比实验**：可以设计一个对比实验，禁用或简化对 slot 和 memory 的操作，观察模糊测试的覆盖率是否有显著提升。如果覆盖率显著提升，说明 slot 和 memory 确实阻碍了探索。

### 2. 修改 Solver 和 FuncScheduler

在处理 JUMPI 的展开树时，如果存在 SLOAD 和 MLOAD 操作，需要进行额外的处理。以下是具体的修改步骤：

#### 2.1 第一次求解

1. **第一次求解**：在第一次求解时，不再将 SLOAD 和 MLOAD 符号化。这样可以避免在初始阶段就引入复杂的符号化状态。

2. **提交到上层**：将访问 SLOAD 和 MLOAD 的操作提交到上层，以便后续处理。

#### 2.2 第二次求解

1. **第二次求解**：针对被访问的 slot，执行第二次 Solver。这次 Solver 将尝试将 SLOAD 和 MLOAD 符号化，得到一个求解的值。

2. **递归执行**：针对 SSTORE 位置执行展开和 Solver。该过程应该递归执行，直到某个 SSTORE 的展开树是纯粹的（即均退化到来自 argument 和 magic number）。

#### 2.3 支持跨函数求解

1. **保存 SSTORE 的展开层**：为了支持跨函数求解，每次函数 Fuzz 时，总是保存一份 SSTORE 的展开层。这样可以支持并行执行，并且在跨函数求解时能够回溯到之前的展开状态。

2. **并行执行**：利用保存的 SSTORE 展开层，可以在不同的线程或进程中并行执行求解过程，提高效率。

## Fuzz Stage

在 Fuzzing 的整体阶段中，确实可以分为几个关键步骤来有效地探索和测试智能合约的安全性。以下是对你提到的三个阶段的详细解释：

### 1. 使用 Contract Creator 作为 `msg.sender`

**目的：** 这一阶段的主要目的是尽可能地探索合约的结构，包括控制流图（CFG）和存储槽（SLOT）之间的关系。由于合约创建者（Contract Creator）通常拥有较高的权限，因此可以更快地获取合约的结构信息。

**具体目标：**
- **分支覆盖率（Branch Coverage）：** 尽可能覆盖合约中的所有分支，以确保没有遗漏任何潜在的逻辑路径。
- **基本块覆盖率（BasicBlock Coverage）：** 确保每个基本块（Basic Block）都被执行到，以全面了解合约的执行流程。

**工具和方法：**
- **SafeReceiver：** 在这一阶段启用 SafeReceiver 作为接收函数，以确保在探索合约结构时不会触发潜在的危险操作。

### 2. Real Fuzzing 使用 External Address 作为交互对象

**目的：** 在第一阶段的基础上，使用外部地址（External Address）作为交互对象进行实际的模糊测试。由于第一阶段已经探索了合约的结构，这一阶段可以更快地获得进度。

**具体目标：**
- **CALL 覆盖率：** 确保合约中的所有 `CALL` 操作都被触发，以测试合约与其他合约或外部账户的交互。
- **SSTORE 覆盖率：** 确保合约中的所有 `SSTORE` 操作都被触发，以测试合约对存储槽的写入操作。

**工具和方法：**
- **External Address：** 使用外部地址作为交互对象，模拟真实的用户或合约与目标合约的交互。

### 3. Reentrancy Fuzzing

**目的：** 在第二阶段的基础上，进一步引导 Reentrancy 攻击的测试。Reentrancy 是一种常见的智能合约漏洞，攻击者可以通过回调机制在合约执行过程中多次执行恶意代码。

**具体目标：**
- **CALL 位置的回调字节码生成：** 对于合约中的 `CALL` 操作，不再使用 SafeReceiver，而是尝试生成回调字节码，以触发 Reentrancy 攻击。

**工具和方法：**
- **回调字节码生成：** 在 `CALL` 操作的位置生成回调字节码，模拟攻击者通过回调机制多次执行恶意代码。

### 总结

通过这三个阶段的逐步推进，可以有效地探索和测试智能合约的安全性。第一阶段通过 Contract Creator 探索合约结构，第二阶段使用 External Address 进行实际的模糊测试，第三阶段则针对 Reentrancy 攻击进行专门的测试。这种分阶段的测试方法可以提高测试效率，并更全面地发现合约中的潜在漏洞。

## Symbolic CFG Solver


(discover)Block 213:
        0x17e1(6113) POP  
        0x17e2(6114) CALLER  
        0x17e3(6115) PUSH20 0xffffffffffffffffffffffffffffffffffffffff 
        0x17f8(6136) AND  
        0x17f9(6137) DUP3  
        0x17fa(6138) PUSH20 0xffffffffffffffffffffffffffffffffffffffff 
        0x180f(6159) AND  
        0x1810(6160) EQ  
        0x1811(6161) ISZERO  

(discover)Block 214:
        0x1812(6162) JUMPDEST  
        0x1813(6163) DUP1  
        0x1814(6164) ISZERO  
        0x1815(6165) PUSH2 0x1823 
        0x1818(6168) JUMPI  
